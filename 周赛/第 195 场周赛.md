| 判断路径是否相交 | 检查数组对是否可以被k整除 | 满足条件的子序列数目 | 满足不等式的最大值 |
| ---------------- | ------------------------- | -------------------- | ------------------ |
| 3分 简单         | 4分 中等                  | 6分 中等             | 7分 困难           |

### 1496 判断路径是否相交

利用pair记录当前的坐标{x,y}

map记录经过的坐标

```C++
class Solution {
public:
    bool isPathCrossing(string path) {
        map<pair<int,int>,int>mp;
        mp[make_pair(0,0)]=1;
        int x=0,y=0;
        for(int i=0;i<path.length();i++){
            if(path[i]=='N'){
                y++;
            }
            else if(path[i]=='E'){
                x++;
            }
            else if(path[i]=='S'){
                y--;
            }
            else{
                x--;
            }
            if(mp[make_pair(x,y)]==1) return true;
            else mp[make_pair(x,y)]=1;
        }
        return false;
    }
};
```

-----

### 1497   检查数组对是否可以被k整除

两个数之和被k整除，即a+b=n*k,n最小可以取1，所以a+b=k

那么我们可以把arr中的所有元素转化为小于k的数

这样我们从小打到排序过后，除0外的元素，最前面的元素一定是与最后面的元素配对，那么和等于k则符合条件，否则不符合条件

对于0特判，只要0的个数不是偶数，就不符合条件

  ```c++
class Solution {
public:
    bool canArrange(vector<int>& arr, int k) {
        int n=arr.size();
        for(int i=0;i<n;i++){
            arr[i]%=k;
            arr[i]=(arr[i]+k)%k;
        }
        sort(arr.begin(),arr.end());
        int l=0;
        while(l<n&&arr[l]==0){
            l++;
        }
        if(l&1) return false;
        int r=n-1;
        while(l<r&&l<n){
            if(arr[l]+arr[r]==k){
                l++;r--;
            }
            else{
                return false;
            }
        }
        return true;
    }
};
  ```



----

### 1498 满足条件的子序列数目



 ```c++

 ```



----

### 1499 满足不等式的最大值



```c++

```

